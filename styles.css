/* =========================================================
   SRT Community Front (Static) - app.js (Full Replace)
   - API: Cloudflare Workers + D1 + DurableObject (Realtime)
   - Features: Auth, Posts, Comments, Markdown, Realtime, UX
   ========================================================= */

"use strict";

/* ======================= CONFIG ======================= */
const API_BASE = "https://srt-community-api.yekong0728.workers.dev";

const STORAGE = {
  token: "srt_token",
  user: "srt_user",
  draftPost: "srt_draft_post",
  draftCommentPrefix: "srt_draft_comment_", // + postId
  ui: "srt_ui",
};

const CATEGORIES = [
  { key: "all", label: "ì „ì²´" },
  { key: "free", label: "ììœ " },
  { key: "notice", label: "ê³µì§€" },
  { key: "qna", label: "Q&A" },
  { key: "study", label: "ìŠ¤í„°ë””" },
];

const SORTS = [
  { key: "latest", label: "ìµœì‹ " },
  { key: "hot", label: "í•«" },
];

const DEFAULTS = {
  category: "all",
  sort: "latest",
  pageSize: 50,
};

const WS_CHANNEL = "feed";
const WS_URL = () => `wss://${new URL(API_BASE).host}/realtime?channel=${encodeURIComponent(WS_CHANNEL)}`;

const API_TIMEOUT_MS = 12000;
const MAX_BODY_MD = 20000;
const MAX_COMMENT_MD = 10000;

/* ======================= UTIL ======================= */
const $ = (sel, root = document) => root.querySelector(sel);
const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function safeText(s, max = 2000) {
  const t = String(s ?? "").trim();
  return t.length > max ? t.slice(0, max) : t;
}

function formatTimeAgo(ms) {
  const t = Number(ms || 0);
  if (!t) return "";
  const diff = Date.now() - t;
  const sec = Math.floor(diff / 1000);
  if (sec < 10) return "ë°©ê¸ˆ";
  if (sec < 60) return `${sec}ì´ˆ ì „`;
  const min = Math.floor(sec / 60);
  if (min < 60) return `${min}ë¶„ ì „`;
  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}ì‹œê°„ ì „`;
  const day = Math.floor(hr / 24);
  if (day < 7) return `${day}ì¼ ì „`;
  const d = new Date(t);
  return `${d.getFullYear()}.${String(d.getMonth() + 1).padStart(2, "0")}.${String(d.getDate()).padStart(2, "0")}`;
}

function debounce(fn, ms) {
  let id = null;
  return (...args) => {
    clearTimeout(id);
    id = setTimeout(() => fn(...args), ms);
  };
}

function loadScript(url) {
  return new Promise((resolve, reject) => {
    const s = document.createElement("script");
    s.src = url;
    s.async = true;
    s.onload = resolve;
    s.onerror = () => reject(new Error("Failed to load: " + url));
    document.head.appendChild(s);
  });
}

async function ensureMarkdownLibs() {
  // marked + DOMPurify ë¡œë“œ (ì—†ìœ¼ë©´ CDNì—ì„œ)
  if (!window.marked) {
    await loadScript("https://cdn.jsdelivr.net/npm/marked/marked.min.js");
  }
  if (!window.DOMPurify) {
    await loadScript("https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js");
  }

  // ì˜µì…˜ ì„¸íŒ…
  try {
    window.marked.setOptions({
      gfm: true,
      breaks: true,
      mangle: false,
      headerIds: false,
    });
  } catch {}
}

function renderMarkdown(md) {
  const raw = String(md ?? "");
  // marked/DOMPurify ì—†ì„ ë•Œë„ ë™ì‘í•˜ê²Œ fallback
  if (!window.marked || !window.DOMPurify) {
    // ìµœì†Œí•œì˜ ì¤„ë°”ê¿ˆë§Œ
    return `<p>${escapeHtml(raw).replaceAll("\n", "<br>")}</p>`;
  }
  const html = window.marked.parse(raw);
  const clean = window.DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "p",
      "br",
      "a",
      "strong",
      "em",
      "del",
      "code",
      "pre",
      "blockquote",
      "ul",
      "ol",
      "li",
      "h1",
      "h2",
      "h3",
      "h4",
      "hr",
      "img",
      "table",
      "thead",
      "tbody",
      "tr",
      "th",
      "td",
    ],
    ALLOWED_ATTR: ["href", "target", "rel", "src", "alt", "title"],
  });

  // ë§í¬ target/rel ë³´ê°•
  const tmp = document.createElement("div");
  tmp.innerHTML = clean;
  $$("a", tmp).forEach((a) => {
    a.setAttribute("target", "_blank");
    a.setAttribute("rel", "noopener noreferrer");
  });
  $$("img", tmp).forEach((img) => {
    img.setAttribute("loading", "lazy");
    img.setAttribute("referrerpolicy", "no-referrer");
  });
  return tmp.innerHTML;
}

/* ======================= API ======================= */
function getToken() {
  return localStorage.getItem(STORAGE.token) || "";
}
function setToken(t) {
  if (t) localStorage.setItem(STORAGE.token, t);
  else localStorage.removeItem(STORAGE.token);
}
function getCachedUser() {
  try {
    const s = localStorage.getItem(STORAGE.user);
    return s ? JSON.parse(s) : null;
  } catch {
    return null;
  }
}
function setCachedUser(u) {
  if (u) localStorage.setItem(STORAGE.user, JSON.stringify(u));
  else localStorage.removeItem(STORAGE.user);
}

async function apiFetch(path, opts = {}) {
  const url = path.startsWith("http") ? path : `${API_BASE}${path}`;
  const headers = new Headers(opts.headers || {});
  headers.set("content-type", headers.get("content-type") || "application/json");
  const token = getToken();
  if (token) headers.set("Authorization", `Bearer ${token}`);

  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

  let res;
  try {
    res = await fetch(url, {
      ...opts,
      headers,
      signal: controller.signal,
    });
  } finally {
    clearTimeout(t);
  }

  // ì‘ë‹µ íŒŒì‹±
  const ct = (res.headers.get("content-type") || "").toLowerCase();
  const isJson = ct.includes("application/json");
  const data = isJson ? await res.json().catch(() => null) : await res.text().catch(() => "");

  if (!res.ok) {
    const msg =
      (data && data.error) ||
      (typeof data === "string" && data) ||
      `HTTP ${res.status}`;
    const err = new Error(msg);
    err.status = res.status;
    err.payload = data;
    throw err;
  }
  return data;
}

/* ======================= UI BASE ======================= */
function injectBaseStylesIfNeeded() {
  // ê¸°ì¡´ styles.cssê°€ ìˆë”ë¼ë„, ìµœì†Œí•œ â€œì•ˆ ë³´ì´ëŠ” í°ê¸€ìâ€ ê°™ì€ ë¬¸ì œë¥¼ ë§‰ê¸° ìœ„í•´ ì•ˆì „ë§ ìŠ¤íƒ€ì¼ ì£¼ì…
  if ($("#__srt_inline_style")) return;

  const style = document.createElement("style");
  style.id = "__srt_inline_style";
  style.textContent = `
  :root{
    --bg1:#0b1220; --bg2:#0a1b16;
    --card: rgba(255,255,255,.06);
    --card2: rgba(255,255,255,.08);
    --stroke: rgba(255,255,255,.12);
    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.70);
    --muted2: rgba(255,255,255,.55);
    --accent: rgba(99,102,241,.95);
    --ok: rgba(34,197,94,.95);
    --warn: rgba(245,158,11,.95);
    --danger: rgba(239,68,68,.95);
    --shadow: 0 16px 60px rgba(0,0,0,.35);
    --r: 18px;
    --r2: 24px;
    --gap: 14px;
    --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", Arial, sans-serif;
  }
  html,body{height:100%;}
  body{
    margin:0;
    font-family:var(--font);
    color:var(--text);
    background:
      radial-gradient(900px 700px at 15% 10%, rgba(99,102,241,.35), transparent 60%),
      radial-gradient(900px 700px at 85% 20%, rgba(34,197,94,.25), transparent 60%),
      radial-gradient(1000px 800px at 30% 90%, rgba(168,85,247,.18), transparent 60%),
      linear-gradient(135deg, var(--bg1), var(--bg2));
    overflow-x:hidden;
  }
  a{color:inherit}
  .srt-wrap{max-width:1100px;margin:0 auto;padding:24px 18px 80px;}
  .srt-header{
    display:flex;align-items:center;justify-content:space-between;
    gap:12px;margin-bottom:16px;
  }
  .srt-brand{display:flex;align-items:center;gap:10px;}
  .srt-logo{
    width:40px;height:40px;border-radius:14px;
    background: linear-gradient(135deg, rgba(99,102,241,.95), rgba(34,197,94,.80));
    box-shadow: var(--shadow);
  }
  .srt-title{display:flex;flex-direction:column;line-height:1.1}
  .srt-title b{font-size:16px}
  .srt-title span{font-size:12px;color:var(--muted)}
  .srt-right{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 12px;border-radius:999px;
    background: rgba(255,255,255,.06);
    border:1px solid var(--stroke);
    font-size:12px;color:var(--muted);
    user-select:none;
  }
  .dot{width:8px;height:8px;border-radius:999px;background: rgba(255,255,255,.35)}
  .dot.ok{background: var(--ok)}
  .dot.bad{background: var(--danger)}
  .btn{
    appearance:none;border:1px solid var(--stroke);
    background: rgba(255,255,255,.06);
    color:var(--text);
    padding:10px 12px;border-radius:14px;
    cursor:pointer;
    transition: transform .06s ease, background .15s ease, border-color .15s ease;
    font-weight:600;font-size:13px;
  }
  .btn:hover{background: rgba(255,255,255,.09);border-color: rgba(255,255,255,.18);}
  .btn:active{transform: translateY(1px);}
  .btn.primary{background: rgba(99,102,241,.25);border-color: rgba(99,102,241,.55)}
  .btn.primary:hover{background: rgba(99,102,241,.32)}
  .btn.ok{background: rgba(34,197,94,.18);border-color: rgba(34,197,94,.45)}
  .btn.danger{background: rgba(239,68,68,.16);border-color: rgba(239,68,68,.45)}
  .btn.ghost{background: transparent;}
  .grid{display:grid;grid-template-columns: 1fr; gap: var(--gap);}
  @media (min-width: 980px){ .grid{grid-template-columns: 1.05fr .95fr;} }

  .panel{
    background: rgba(255,255,255,.06);
    border:1px solid var(--stroke);
    border-radius: var(--r2);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .panel-head{
    padding:14px 14px 12px;
    border-bottom:1px solid rgba(255,255,255,.10);
    display:flex;gap:10px;align-items:center;justify-content:space-between;
    flex-wrap:wrap;
  }
  .panel-head h2{margin:0;font-size:14px;letter-spacing:.2px}
  .panel-body{padding:14px;}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{
    padding:8px 10px;border-radius:999px;
    background: rgba(255,255,255,.06);
    border:1px solid var(--stroke);
    color:var(--muted);
    cursor:pointer;
    font-weight:700;font-size:12px;
    transition: background .15s ease,border-color .15s ease, transform .06s ease;
    user-select:none;
  }
  .pill:hover{background: rgba(255,255,255,.09);border-color: rgba(255,255,255,.18);}
  .pill.active{background: rgba(99,102,241,.26);border-color: rgba(99,102,241,.55); color: rgba(255,255,255,.92);}
  .input, .select, textarea{
    width:100%;
    box-sizing:border-box;
    border-radius: 14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.20);
    color: var(--text);
    padding:10px 12px;
    outline:none;
    transition: border-color .15s ease, background .15s ease;
    font-size:13px;
  }
  .input:focus, textarea:focus, .select:focus{border-color: rgba(99,102,241,.65);background: rgba(0,0,0,.26);}
  textarea{min-height:120px;resize:vertical;line-height:1.5}
  .help{font-size:12px;color: var(--muted2);line-height:1.45}
  .split{display:flex;gap:10px;align-items:center}
  .split > *{flex:1}
  .post{
    padding:12px 12px;
    border-radius: var(--r);
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    cursor:pointer;
    transition: transform .06s ease, background .15s ease, border-color .15s ease;
  }
  .post:hover{background: rgba(0,0,0,.22);border-color: rgba(255,255,255,.16);}
  .post:active{transform: translateY(1px);}
  .post .meta{display:flex;gap:10px;align-items:center;justify-content:space-between;color:var(--muted);font-size:12px;margin-bottom:6px}
  .post .title{font-weight:900;letter-spacing:.1px}
  .post .sub{color:var(--muted2);font-size:12px;margin-top:6px;display:flex;gap:10px;flex-wrap:wrap}
  .tag{
    display:inline-flex;align-items:center;gap:6px;
    padding:4px 8px;border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.05);
    font-size:12px;color: var(--muted);
  }
  .kpi{display:inline-flex;gap:8px;align-items:center}
  .kpi b{color: var(--text)}
  .hr{height:1px;background: rgba(255,255,255,.10);margin:12px 0}
  .empty{
    padding:22px 14px;border:1px dashed rgba(255,255,255,.20);
    border-radius: var(--r);
    color: var(--muted);
    background: rgba(255,255,255,.04);
  }

  /* Markdown */
  .md h1,.md h2,.md h3,.md h4{margin:10px 0 6px;line-height:1.25}
  .md h1{font-size:1.35rem}
  .md h2{font-size:1.2rem}
  .md h3{font-size:1.05rem}
  .md p{margin:6px 0;line-height:1.6}
  .md blockquote{
    margin:8px 0;padding:10px 12px;border-radius: 16px;
    border-left: 3px solid rgba(255,255,255,.30);
    background: rgba(255,255,255,.06);
    color: rgba(255,255,255,.88);
  }
  .md code{padding:2px 6px;border-radius:10px;background: rgba(0,0,0,.28)}
  .md pre{padding:12px 12px;border-radius:18px;background: rgba(0,0,0,.38);overflow:auto}
  .md img{max-width:100%;border-radius:18px;display:block;margin:10px 0;border:1px solid rgba(255,255,255,.10)}
  .md table{width:100%;border-collapse:collapse;margin:10px 0;overflow:auto}
  .md th,.md td{border:1px solid rgba(255,255,255,.12);padding:8px 10px;font-size:13px}
  .md a{text-decoration: underline}

  /* Modal */
  .overlay{
    position:fixed;inset:0;
    background: rgba(0,0,0,.55);
    display:none;align-items:center;justify-content:center;
    padding:18px;z-index:9999;
  }
  .overlay.show{display:flex}
  .modal{
    width:min(820px, 100%);
    border-radius: 26px;
    border:1px solid rgba(255,255,255,.16);
    background: rgba(15,23,42,.92);
    box-shadow: 0 30px 120px rgba(0,0,0,.55);
    overflow:hidden;
  }
  .modal-head{padding:14px 14px;border-bottom:1px solid rgba(255,255,255,.10);display:flex;justify-content:space-between;align-items:center;gap:10px}
  .modal-head b{font-size:14px}
  .modal-body{padding:14px}
  .modal-foot{padding:14px;border-top:1px solid rgba(255,255,255,.10);display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap}
  .x{cursor:pointer;border:1px solid rgba(255,255,255,.14);background: rgba(255,255,255,.06);border-radius:14px;padding:8px 10px;font-weight:900}

  /* Toast */
  .toast-wrap{position:fixed;right:16px;bottom:16px;display:flex;flex-direction:column;gap:10px;z-index:10000}
  .toast{
    width:min(420px, calc(100vw - 32px));
    background: rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.14);
    color: var(--text);
    border-radius: 18px;
    padding: 10px 12px;
    box-shadow: var(--shadow);
  }
  .toast .t{font-weight:900;font-size:13px}
  .toast .m{margin-top:4px;color: var(--muted);font-size:12px;line-height:1.45}
  `;
  document.head.appendChild(style);
}

function ensureRoot() {
  let root = $("#app");
  if (!root) {
    root = document.createElement("div");
    root.id = "app";
    document.body.appendChild(root);
  }
  return root;
}

function toast(title, msg = "", type = "info", ms = 2800) {
  let wrap = $("#__toast_wrap");
  if (!wrap) {
    wrap = document.createElement("div");
    wrap.id = "__toast_wrap";
    wrap.className = "toast-wrap";
    document.body.appendChild(wrap);
  }
  const el = document.createElement("div");
  el.className = "toast";
  el.innerHTML = `<div class="t">${escapeHtml(title)}</div><div class="m">${escapeHtml(msg)}</div>`;
  if (type === "ok") el.style.borderColor = "rgba(34,197,94,.35)";
  if (type === "bad") el.style.borderColor = "rgba(239,68,68,.35)";
  if (type === "warn") el.style.borderColor = "rgba(245,158,11,.35)";
  wrap.appendChild(el);
  setTimeout(() => {
    el.style.opacity = "0";
    el.style.transform = "translateY(6px)";
    el.style.transition = "all .25s ease";
    setTimeout(() => el.remove(), 260);
  }, ms);
}

function makeOverlay() {
  let ov = $("#__overlay");
  if (ov) return ov;
  ov = document.createElement("div");
  ov.id = "__overlay";
  ov.className = "overlay";
  ov.innerHTML = `<div class="modal" role="dialog" aria-modal="true"></div>`;
  ov.addEventListener("click", (e) => {
    if (e.target === ov) closeModal();
  });
  document.body.appendChild(ov);
  return ov;
}

function openModal(title, bodyHtml, footerHtml = "", { onMount } = {}) {
  const ov = makeOverlay();
  const modal = $(".modal", ov);
  modal.innerHTML = `
    <div class="modal-head">
      <b>${escapeHtml(title)}</b>
      <button class="x" aria-label="Close">âœ•</button>
    </div>
    <div class="modal-body">${bodyHtml}</div>
    <div class="modal-foot">${footerHtml}</div>
  `;
  $(".x", modal).addEventListener("click", closeModal);
  ov.classList.add("show");
  document.body.style.overflow = "hidden";
  if (onMount) onMount(modal);
}

function closeModal() {
  const ov = $("#__overlay");
  if (!ov) return;
  ov.classList.remove("show");
  document.body.style.overflow = "";
}

/* ======================= STATE ======================= */
const state = {
  me: getCachedUser(),
  token: getToken(),
  ws: null,
  wsStatus: "idle", // idle|connecting|open|closed|error
  wsLastMsgAt: 0,

  // feed state
  category: DEFAULTS.category,
  sort: DEFAULTS.sort,
  q: "",
  cursor: "",
  pageSize: DEFAULTS.pageSize,
  loading: false,
  posts: [],
  nextCursor: "",
  selectedPostId: "",
  selectedPost: null,
  comments: [],
  commentsLoading: false,
};

function loadUiPrefs() {
  try {
    const s = localStorage.getItem(STORAGE.ui);
    if (!s) return;
    const u = JSON.parse(s);
    if (u.category) state.category = u.category;
    if (u.sort) state.sort = u.sort;
    if (typeof u.q === "string") state.q = u.q;
  } catch {}
}
function saveUiPrefs() {
  localStorage.setItem(STORAGE.ui, JSON.stringify({ category: state.category, sort: state.sort, q: state.q }));
}

/* ======================= AUTH ======================= */
async function authMeSilent() {
  if (!getToken()) return;
  try {
    const r = await apiFetch("/auth/me", { method: "GET", headers: {} });
    if (r && r.ok && r.user) {
      state.me = r.user;
      setCachedUser(r.user);
      render();
    }
  } catch {
    // token expired
    setToken("");
    setCachedUser(null);
    state.me = null;
    state.token = "";
    render();
  }
}

async function authRegister({ nickname, password, studentId }) {
  const body = { nickname, password, studentId: studentId || "" };
  return apiFetch("/auth/register", { method: "POST", body: JSON.stringify(body) });
}
async function authLogin({ identifier, password }) {
  const body = { identifier, password };
  const r = await apiFetch("/auth/login", { method: "POST", body: JSON.stringify(body) });
  if (r && r.ok && r.token) {
    setToken(r.token);
    state.token = r.token;
    state.me = r.user || null;
    setCachedUser(state.me);
  }
  return r;
}
async function authLogout() {
  try {
    await apiFetch("/auth/logout", { method: "POST", body: JSON.stringify({}) });
  } catch {}
  setToken("");
  setCachedUser(null);
  state.me = null;
  state.token = "";
  toast("ë¡œê·¸ì•„ì›ƒ", "ì™„ë£Œ", "ok");
  render();
}

/* ======================= POSTS/COMMENTS ======================= */
async function fetchPosts({ reset = false } = {}) {
  if (state.loading) return;
  state.loading = true;
  render();

  try {
    const params = new URLSearchParams();
    params.set("category", state.category);
    params.set("sort", state.sort);
    if (state.q.trim()) params.set("q", state.q.trim());
    params.set("pageSize", String(clamp(state.pageSize, 10, 200)));
    if (!reset && state.nextCursor) params.set("cursor", state.nextCursor);

    const r = await apiFetch(`/posts?${params.toString()}`, { method: "GET", headers: {} });
    if (r && r.ok) {
      const newPosts = r.posts || [];
      if (reset) state.posts = newPosts;
      else state.posts = [...state.posts, ...newPosts];
      state.nextCursor = r.nextCursor || "";
    }
  } catch (e) {
    toast("ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨", e.message || "API ì˜¤ë¥˜", "bad", 4200);
  } finally {
    state.loading = false;
    render();
  }
}

async function fetchPost(postId) {
  state.selectedPostId = postId;
  state.selectedPost = null;
  state.comments = [];
  render();

  try {
    const r = await apiFetch(`/posts/${encodeURIComponent(postId)}`, { method: "GET", headers: {} });
    if (r && r.ok && r.post) {
      state.selectedPost = r.post;
      render();
      await fetchComments(postId);
    }
  } catch (e) {
    toast("ê²Œì‹œê¸€ ì—´ê¸° ì‹¤íŒ¨", e.message || "API ì˜¤ë¥˜", "bad", 4200);
    state.selectedPostId = "";
    state.selectedPost = null;
    state.comments = [];
    render();
  }
}

async function fetchComments(postId) {
  state.commentsLoading = true;
  render();
  try {
    const r = await apiFetch(`/posts/${encodeURIComponent(postId)}/comments`, { method: "GET", headers: {} });
    if (r && r.ok) {
      state.comments = r.comments || [];
    }
  } catch (e) {
    toast("ëŒ“ê¸€ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨", e.message || "API ì˜¤ë¥˜", "bad", 4200);
    state.comments = [];
  } finally {
    state.commentsLoading = false;
    render();
  }
}

async function createPost({ category, title, bodyMd, anonymous }) {
  const body = { category, title, bodyMd, anonymous: !!anonymous };
  const r = await apiFetch("/posts", { method: "POST", body: JSON.stringify(body) });
  return r;
}

async function editPost(postId, patch) {
  const r = await apiFetch(`/posts/${encodeURIComponent(postId)}`, { method: "PATCH", body: JSON.stringify(patch) });
  return r;
}

async function deletePost(postId) {
  const r = await apiFetch(`/posts/${encodeURIComponent(postId)}`, { method: "DELETE", headers: {} });
  return r;
}

async function createComment(postId, { bodyMd, anonymous }) {
  const body = { bodyMd, anonymous: !!anonymous };
  const r = await apiFetch(`/posts/${encodeURIComponent(postId)}/comments`, { method: "POST", body: JSON.stringify(body) });
  return r;
}

async function toggleLike(targetType, targetId) {
  const body = { targetType, targetId };
  const r = await apiFetch("/likes/toggle", { method: "POST", body: JSON.stringify(body) });
  return r;
}

async function report(targetType, targetId, reason, detail) {
  const body = { targetType, targetId, reason, detail };
  const r = await apiFetch("/reports", { method: "POST", body: JSON.stringify(body) });
  return r;
}

/* ======================= REALTIME (WS) ======================= */
function wsClose() {
  try {
    if (state.ws) state.ws.close();
  } catch {}
  state.ws = null;
}

function wsConnect() {
  wsClose();
  state.wsStatus = "connecting";
  render();

  let ws;
  try {
    ws = new WebSocket(WS_URL());
  } catch (e) {
    state.wsStatus = "error";
    render();
    return;
  }

  state.ws = ws;

  ws.onopen = () => {
    state.wsStatus = "open";
    render();
    // keepalive ping
    try {
      ws.send("ping");
    } catch {}
  };

  ws.onmessage = (evt) => {
    state.wsLastMsgAt = Date.now();
    let data = null;
    try {
      data = JSON.parse(evt.data);
    } catch {
      return;
    }
    if (!data || !data.payload) return;

    // payload example: { kind: "post_created", postId, createdAt }
    const p = data.payload;
    handleRealtimeEvent(p);
  };

  ws.onerror = () => {
    state.wsStatus = "error";
    render();
  };

  ws.onclose = () => {
    state.wsStatus = "closed";
    render();
    // backoff reconnect
    setTimeout(() => wsConnect(), 1200);
  };
}

async function handleRealtimeEvent(payload) {
  const kind = payload.kind;
  if (!kind) return;

  // UX: ë„ˆë¬´ ì¦ì€ ìë™ ìƒˆë¡œê³ ì¹¨ ë°©ì§€
  // "ìµœì‹  + ê²€ìƒ‰ ì—†ìŒ + ì „ì²´/ì¹´í…Œê³ ë¦¬ í•„í„°ë§Œ"ì¼ ë•ŒëŠ” ì¦‰ì‹œ ìƒë‹¨ ê°±ì‹ 
  const shouldAutoUpdate = state.sort === "latest" && !state.q.trim();

  if (kind === "post_created") {
    if (shouldAutoUpdate) {
      // ìƒë‹¨ë§Œ ìƒˆë¡œ ë¡œë”© (reset)
      await fetchPosts({ reset: true });
    }
    // í˜„ì¬ ìƒì„¸ê¸€ì´ ì—´ë ¤ìˆì§€ ì•Šë‹¤ë©´ ê°€ë²¼ìš´ í† ìŠ¤íŠ¸
    if (!state.selectedPostId) toast("ìƒˆ ê¸€", "ìƒˆ ê²Œì‹œê¸€ì´ ì˜¬ë¼ì™”ì–´ìš”", "ok", 1600);
    return;
  }

  if (kind === "post_updated" || kind === "post_removed") {
    // ëª©ë¡/ìƒì„¸ì— ë°˜ì˜: ê°„ë‹¨íˆ reset (í™•ì‹¤)
    if (shouldAutoUpdate) await fetchPosts({ reset: true });
    if (state.selectedPostId && payload.postId === state.selectedPostId) {
      if (kind === "post_removed") {
        toast("ì‚­ì œë¨", "ì´ ê²Œì‹œê¸€ì€ ì‚­ì œë˜ì—ˆì–´ìš”", "warn", 2400);
        state.selectedPostId = "";
        state.selectedPost = null;
        state.comments = [];
        render();
      } else {
        await fetchPost(state.selectedPostId);
      }
    }
    return;
  }

  if (kind === "comment_created") {
    // ìƒì„¸ í™”ë©´ì—ì„œë§Œ ëŒ“ê¸€ ê°±ì‹ 
    if (state.selectedPostId && payload.postId === state.selectedPostId) {
      await fetchComments(state.selectedPostId);
      // ëŒ“ê¸€ ìˆ˜ ê°±ì‹ ì„ ìœ„í•´ ìƒì„¸ ì¬ì¡°íšŒ
      await fetchPost(state.selectedPostId);
    } else {
      // ëª©ë¡ì˜ ëŒ“ê¸€ìˆ˜ë§Œ ì—…ë°ì´íŠ¸(ìµœëŒ€í•œ ê°€ë³ê²Œ)
      const idx = state.posts.findIndex((x) => x.id === payload.postId);
      if (idx >= 0) {
        state.posts[idx].comments = (state.posts[idx].comments || 0) + 1;
        render();
      }
    }
    return;
  }
}

/* ======================= RENDER ======================= */
function layoutTemplate() {
  const me = state.me;
  const wsDot = state.wsStatus === "open" ? "ok" : state.wsStatus === "connecting" ? "" : "bad";
  const wsText =
    state.wsStatus === "open"
      ? "ì‹¤ì‹œê°„ ì—°ê²°ë¨"
      : state.wsStatus === "connecting"
      ? "ì‹¤ì‹œê°„ ì—°ê²°ì¤‘â€¦"
      : state.wsStatus === "closed"
      ? "ì—°ê²° ëŠê¹€(ì¬ì‹œë„ì¤‘)"
      : state.wsStatus === "error"
      ? "ì‹¤ì‹œê°„ ì˜¤ë¥˜(ì¬ì‹œë„ì¤‘)"
      : "ëŒ€ê¸°ì¤‘";

  return `
  <div class="srt-wrap">
    <div class="srt-header">
      <div class="srt-brand">
        <div class="srt-logo" aria-hidden="true"></div>
        <div class="srt-title">
          <b>SRT Community</b>
          <span>ì½ê¸°ëŠ” ëˆ„êµ¬ë‚˜ Â· ì“°ê¸°ëŠ” ë¡œê·¸ì¸ í•„ìš”</span>
        </div>
      </div>

      <div class="srt-right">
        <div class="chip" style="min-width:160px;justify-content:center;">
          <span class="dot ${wsDot}"></span>
          <span>${escapeHtml(wsText)}</span>
        </div>

        ${
          me
            ? `
          <div class="chip">
            <span style="font-weight:900">${escapeHtml(me.nickname)}</span>
            <span style="color:var(--muted2)">${escapeHtml(me.role || "student")}</span>
          </div>
          <button class="btn" id="btnLogout">ë¡œê·¸ì•„ì›ƒ</button>
        `
            : `
          <button class="btn primary" id="btnLogin">ë¡œê·¸ì¸</button>
          <button class="btn" id="btnRegister">íšŒì›ê°€ì…</button>
        `
        }

        <button class="btn ok" id="btnNewPost">+ ìƒˆ ê¸€</button>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: FEED -->
      <div class="panel">
        <div class="panel-head">
          <h2>ê²Œì‹œíŒ</h2>
          <div class="row" style="gap:8px">
            <select class="select" id="sortSel" style="width:auto">
              ${SORTS.map((s) => `<option value="${s.key}" ${s.key === state.sort ? "selected" : ""}>${escapeHtml(s.label)}</option>`).join("")}
            </select>
            <button class="btn" id="btnRefresh">ìƒˆë¡œê³ ì¹¨</button>
          </div>
        </div>
        <div class="panel-body">
          <div class="row" id="catRow">
            ${CATEGORIES.map((c) => `<span class="pill ${c.key === state.category ? "active" : ""}" data-cat="${c.key}">${escapeHtml(c.label)}</span>`).join("")}
          </div>

          <div style="height:10px"></div>

          <div class="row">
            <input class="input" id="qInput" placeholder="ê²€ìƒ‰(ì œëª©/ë‚´ìš©)" value="${escapeHtml(state.q)}" />
            <button class="btn" id="btnSearch">ê²€ìƒ‰</button>
            <button class="btn ghost" id="btnClear" title="ê²€ìƒ‰ ì´ˆê¸°í™”">ì´ˆê¸°í™”</button>
          </div>

          <div class="help" style="margin-top:10px">
            â€¢ ì´ë¯¸ì§€/ë™ì˜ìƒì€ ì—…ë¡œë“œ ëŒ€ì‹  <b>ë§í¬</b>ë¥¼ ë„£ì–´ <code>![](ë§í¬)</code> ë¡œ í‘œì‹œí•  ìˆ˜ ìˆì–´ìš” (ì˜ˆ: catbox).<br>
            â€¢ ë§ˆí¬ë‹¤ìš´ ì§€ì›: <code>#</code> <code>##</code> <code>###</code> <code>**êµµê²Œ**</code> <code>&gt; ì¸ìš©</code> <code>```ì½”ë“œ```</code>
          </div>

          <div class="hr"></div>

          <div id="feedList"></div>

          <div style="height:12px"></div>

          <div class="row" style="justify-content:space-between">
            <div class="help">${state.loading ? "ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦" : state.posts.length ? `${state.posts.length}ê°œ ë¡œë“œë¨` : ""}</div>
            <div class="row" style="gap:8px">
              <button class="btn" id="btnLoadMore" ${state.nextCursor && !state.loading ? "" : "disabled"}>ë” ë³´ê¸°</button>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: DETAIL -->
      <div class="panel">
        <div class="panel-head">
          <h2>ê¸€ ë³´ê¸°</h2>
          <div class="row" style="gap:8px">
            <button class="btn" id="btnCloseDetail" ${state.selectedPostId ? "" : "disabled"}>ë‹«ê¸°</button>
          </div>
        </div>
        <div class="panel-body" id="detailBody">
          ${renderDetail()}
        </div>
      </div>
    </div>
  </div>
  `;
}

function renderFeedList() {
  const wrap = document.createElement("div");

  if (!state.posts.length) {
    const empty = document.createElement("div");
    empty.className = "empty";
    empty.innerHTML = `
      <b style="display:block;margin-bottom:6px">ì•„ì§ ê¸€ì´ ì—†ì–´ìš”.</b>
      <div style="color:var(--muted);line-height:1.45">
        â€¢ ìƒë‹¨ <b>+ ìƒˆ ê¸€</b> ë²„íŠ¼ìœ¼ë¡œ ì²« ê¸€ì„ ì‘ì„±í•´ë³´ì„¸ìš”.<br>
        â€¢ ê´€ë¦¬ì/ìš´ì˜ì€ ê³µì§€ë¥¼ ì˜¬ë ¤ì„œ ì‚¬ìš©ë²•ì„ ì•ˆë‚´í•´ë„ ì¢‹ì•„ìš”.
      </div>
    `;
    wrap.appendChild(empty);
    return wrap;
  }

  state.posts.forEach((p) => {
    const el = document.createElement("div");
    el.className = "post";
    el.dataset.postId = p.id;

    const cat = CATEGORIES.find((c) => c.key === p.category)?.label || p.category;
    const author = p.authorName || "ìµëª…";
    const time = formatTimeAgo(p.createdAt);
    const pinned = p.pinned ? "ğŸ“Œ " : "";

    // ë¯¸ë¦¬ë³´ê¸°(í…ìŠ¤íŠ¸ë§Œ)
    const preview = safeText(p.bodyMd, 140).replaceAll("\n", " ").trim();

    el.innerHTML = `
      <div class="meta">
        <div class="kpi">
          <span class="tag">${escapeHtml(cat)}</span>
          <span style="color:var(--muted2)">${escapeHtml(author)}</span>
          <span style="color:var(--muted2)">Â·</span>
          <span style="color:var(--muted2)">${escapeHtml(time)}</span>
        </div>
        <div class="kpi" style="gap:10px">
          <span title="ì¢‹ì•„ìš”" class="kpi">ğŸ‘ <b>${Number(p.likes || 0)}</b></span>
          <span title="ëŒ“ê¸€" class="kpi">ğŸ’¬ <b>${Number(p.comments || 0)}</b></span>
        </div>
      </div>
      <div class="title">${escapeHtml(pinned + (p.title || ""))}</div>
      <div class="sub">
        <span>${escapeHtml(preview || "")}</span>
      </div>
    `;
    wrap.appendChild(el);
  });

  return wrap;
}

function renderDetail() {
  const p = state.selectedPost;
  if (!state.selectedPostId) {
    return `
      <div class="empty">
        <b style="display:block;margin-bottom:6px">ê¸€ì„ ì„ íƒí•˜ì„¸ìš”.</b>
        <div style="color:var(--muted);line-height:1.45">
          ì™¼ìª½ ëª©ë¡ì—ì„œ ê¸€ì„ í´ë¦­í•˜ë©´ ìƒì„¸ ë‚´ìš©ê³¼ ëŒ“ê¸€ì´ í‘œì‹œë¼ìš”.<br>
          ì‹¤ì‹œê°„ìœ¼ë¡œ 24ì‹œê°„ ì´ë‚´ ê¸€ì˜ ë³€í™”(ìƒˆ ê¸€/ëŒ“ê¸€ ë“±)ë„ ë°˜ì˜ë©ë‹ˆë‹¤.
        </div>
      </div>
    `;
  }

  if (!p) {
    return `<div class="empty">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</div>`;
  }

  const cat = CATEGORIES.find((c) => c.key === p.category)?.label || p.category;
  const time = formatTimeAgo(p.createdAt);
  const author = p.authorName || "ìµëª…";

  const canEdit = !!p.canEdit;
  const canDelete = !!p.canDelete;

  return `
    <div>
      <div class="row" style="justify-content:space-between;align-items:flex-start;gap:10px">
        <div style="min-width:0">
          <div class="row" style="gap:8px;margin-bottom:8px">
            <span class="tag">${escapeHtml(cat)}</span>
            <span style="color:var(--muted)">${escapeHtml(author)}</span>
            <span style="color:var(--muted2)">Â·</span>
            <span style="color:var(--muted2)">${escapeHtml(time)}</span>
          </div>
          <div style="font-weight:1000;font-size:18px;letter-spacing:.2px">${escapeHtml(p.title || "")}</div>
        </div>

        <div class="row" style="gap:8px;justify-content:flex-end">
          <button class="btn" id="btnLikePost">ğŸ‘ ì¢‹ì•„ìš”</button>
          <button class="btn" id="btnReportPost">ğŸš© ì‹ ê³ </button>
          ${canEdit ? `<button class="btn ok" id="btnEditPost">ìˆ˜ì •</button>` : ""}
          ${canDelete ? `<button class="btn danger" id="btnDeletePost">ì‚­ì œ</button>` : ""}
        </div>
      </div>

      <div class="hr"></div>

      <div class="md" id="postBody">${renderMarkdown(p.bodyMd || "")}</div>

      <div class="hr"></div>

      <div class="row" style="justify-content:space-between">
        <b>ëŒ“ê¸€</b>
        <span class="help">${state.commentsLoading ? "ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦" : `${state.comments.length}ê°œ`}</span>
      </div>

      <div style="height:10px"></div>

      ${renderCommentComposer(p.id)}

      <div style="height:10px"></div>

      <div id="commentList">
        ${renderCommentsHtml()}
      </div>
    </div>
  `;
}

function renderCommentComposer(postId) {
  const me = state.me;
  const draftKey = STORAGE.draftCommentPrefix + postId;
  const draft = localStorage.getItem(draftKey) || "";

  const disabled = !me ? "disabled" : "";
  const loginHint = !me ? `<div class="help" style="margin-bottom:10px">ëŒ“ê¸€ ì‘ì„±ì€ ë¡œê·¸ì¸ í›„ ê°€ëŠ¥í•´ìš”.</div>` : "";

  return `
    <div class="panel" style="border-radius:18px;background: rgba(255,255,255,.04);box-shadow:none">
      <div class="panel-body" style="padding:12px">
        ${loginHint}

        <div class="row" style="gap:8px;justify-content:space-between">
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <button class="btn" id="mdH1" ${disabled} title="# í—¤ë”©">#</button>
            <button class="btn" id="mdH2" ${disabled} title="## í—¤ë”©">##</button>
            <button class="btn" id="mdH3" ${disabled} title="### í—¤ë”©">###</button>
            <button class="btn" id="mdBold" ${disabled} title="**êµµê²Œ**"><b>B</b></button>
            <button class="btn" id="mdQuote" ${disabled} title="> ì¸ìš©">â€œ</button>
            <button class="btn" id="mdCode" ${disabled} title="```ì½”ë“œ```">{ }</button>
            <button class="btn" id="mdImg" ${disabled} title="![](ë§í¬)">ğŸ–¼</button>
          </div>

          <label class="chip" style="gap:8px">
            <input type="checkbox" id="commentAnon" ${disabled} />
            <span>ìµëª…</span>
          </label>
        </div>

        <div style="height:10px"></div>

        <textarea class="input" id="commentInput" ${disabled} placeholder="ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš” (ë§ˆí¬ë‹¤ìš´ ì§€ì›)"
          maxlength="${MAX_COMMENT_MD}">${escapeHtml(draft)}</textarea>

        <div class="row" style="justify-content:space-between;margin-top:10px">
          <div class="help">ë¯¸ë¦¬ë³´ê¸°ëŠ” ì•„ë˜ì— ìë™ í‘œì‹œë¼ìš” Â· ë‚¨ì€ ê¸€ì: <span id="commentRemain">${MAX_COMMENT_MD - draft.length}</span></div>
          <div class="row" style="gap:8px">
            <button class="btn" id="btnCommentPreview" ${disabled}>ë¯¸ë¦¬ë³´ê¸°</button>
            <button class="btn primary" id="btnSendComment" ${disabled}>ëŒ“ê¸€ ë“±ë¡</button>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="md" id="commentPreview" style="display:none;border:1px solid rgba(255,255,255,.10);border-radius:18px;padding:12px;background: rgba(0,0,0,.18)"></div>
      </div>
    </div>
  `;
}

function renderCommentsHtml() {
  if (!state.comments.length) {
    return `<div class="empty">ì•„ì§ ëŒ“ê¸€ì´ ì—†ì–´ìš”. ì²« ëŒ“ê¸€ì„ ë‚¨ê²¨ë³´ì„¸ìš”!</div>`;
  }

  return state.comments
    .map((c) => {
      const time = formatTimeAgo(c.createdAt);
      const author = c.authorName || "ìµëª…";
      return `
        <div class="panel" style="border-radius:18px;background: rgba(0,0,0,.16);box-shadow:none;margin-bottom:10px">
          <div class="panel-body" style="padding:12px">
            <div class="row" style="justify-content:space-between">
              <div class="row" style="gap:10px;color:var(--muted);font-size:12px">
                <span style="font-weight:900;color:rgba(255,255,255,.85)">${escapeHtml(author)}</span>
                <span style="color:var(--muted2)">Â·</span>
                <span style="color:var(--muted2)">${escapeHtml(time)}</span>
              </div>
              <div class="row" style="gap:8px">
                <button class="btn" data-like-comment="${escapeHtml(c.id)}">ğŸ‘</button>
                <button class="btn" data-report-comment="${escapeHtml(c.id)}">ğŸš©</button>
                <button class="btn" data-reply="${escapeHtml(c.id)}" data-reply-author="${escapeHtml(author)}">ë‹µê¸€</button>
              </div>
            </div>
            <div style="height:8px"></div>
            <div class="md">${renderMarkdown(c.bodyMd || "")}</div>
          </div>
        </div>
      `;
    })
    .join("");
}

function render() {
  const root = ensureRoot();
  root.innerHTML = layoutTemplate();

  // mount feed list nodes
  const feedList = $("#feedList");
  feedList.innerHTML = "";
  feedList.appendChild(renderFeedList());

  // wire events
  wireGlobalEvents();
}

function wireGlobalEvents() {
  // header auth
  const btnLogin = $("#btnLogin");
  if (btnLogin) btnLogin.onclick = () => openLoginModal();
  const btnRegister = $("#btnRegister");
  if (btnRegister) btnRegister.onclick = () => openRegisterModal();
  const btnLogout = $("#btnLogout");
  if (btnLogout) btnLogout.onclick = () => authLogout();

  // new post
  $("#btnNewPost").onclick = () => openPostComposer();

  // sort
  $("#sortSel").onchange = async (e) => {
    state.sort = e.target.value;
    saveUiPrefs();
    state.nextCursor = "";
    await fetchPosts({ reset: true });
  };

  // refresh
  $("#btnRefresh").onclick = async () => {
    state.nextCursor = "";
    await fetchPosts({ reset: true });
  };

  // close detail
  $("#btnCloseDetail").onclick = () => {
    state.selectedPostId = "";
    state.selectedPost = null;
    state.comments = [];
    render();
  };

  // categories
  $$("#catRow .pill").forEach((p) => {
    p.onclick = async () => {
      state.category = p.dataset.cat || "all";
      saveUiPrefs();
      state.nextCursor = "";
      await fetchPosts({ reset: true });
    };
  });

  // search
  const qInput = $("#qInput");
  const doSearch = debounce(async () => {
    state.q = qInput.value || "";
    saveUiPrefs();
    state.nextCursor = "";
    await fetchPosts({ reset: true });
  }, 350);

  qInput.addEventListener("input", () => doSearch());
  $("#btnSearch").onclick = async () => {
    state.q = qInput.value || "";
    saveUiPrefs();
    state.nextCursor = "";
    await fetchPosts({ reset: true });
  };
  $("#btnClear").onclick = async () => {
    qInput.value = "";
    state.q = "";
    saveUiPrefs();
    state.nextCursor = "";
    await fetchPosts({ reset: true });
  };

  // load more
  $("#btnLoadMore").onclick = async () => {
    if (!state.nextCursor || state.loading) return;
    await fetchPosts({ reset: false });
  };

  // click post in list
  $$("#feedList .post").forEach((node) => {
    node.onclick = async () => {
      const id = node.dataset.postId;
      if (id) await fetchPost(id);
    };
  });

  // detail buttons
  const p = state.selectedPost;

  if (p) {
    const btnLike = $("#btnLikePost");
    if (btnLike) {
      btnLike.onclick = async () => {
        if (!state.me) return toast("ë¡œê·¸ì¸ í•„ìš”", "ì¢‹ì•„ìš”ëŠ” ë¡œê·¸ì¸ í›„ ê°€ëŠ¥í•´ìš”", "warn");
        try {
          const r = await toggleLike("post", p.id);
          toast(r.liked ? "ì¢‹ì•„ìš”" : "ì¢‹ì•„ìš” ì·¨ì†Œ", "", "ok", 1400);
          // ìµœì‹  ìƒíƒœ ê°±ì‹ 
          await fetchPost(p.id);
          // ëª©ë¡ë„ ì•½ê°„ ë°˜ì˜
          const idx = state.posts.findIndex((x) => x.id === p.id);
          if (idx >= 0) await fetchPosts({ reset: true });
        } catch (e) {
          toast("ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 2600);
        }
      };
    }

    const btnReport = $("#btnReportPost");
    if (btnReport) btnReport.onclick = () => openReportModal("post", p.id);

    const btnEdit = $("#btnEditPost");
    if (btnEdit) btnEdit.onclick = () => openEditPostModal(p);

    const btnDelete = $("#btnDeletePost");
    if (btnDelete) {
      btnDelete.onclick = () => openConfirm(
        "ì‚­ì œ",
        "ì´ ê¸€ì„ ì‚­ì œí• ê¹Œìš”? (ì‚­ì œëŠ” ê´€ë¦¬ì/ìš´ì˜ìë§Œ ê°€ëŠ¥)",
        async () => {
          try {
            await deletePost(p.id);
            toast("ì‚­ì œë¨", "ê²Œì‹œê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤", "ok");
            state.selectedPostId = "";
            state.selectedPost = null;
            state.comments = [];
            await fetchPosts({ reset: true });
          } catch (e) {
            toast("ì‚­ì œ ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 3200);
          }
        }
      );
    }

    // comment composer wires
    wireCommentComposer(p.id);
    wireCommentListActions(p.id);
  }
}

/* ======================= MODALS ======================= */
function openConfirm(title, msg, onYes) {
  openModal(
    title,
    `<div style="line-height:1.5;color:var(--muted)">${escapeHtml(msg)}</div>`,
    `<button class="btn" id="btnNo">ì·¨ì†Œ</button>
     <button class="btn danger" id="btnYes">í™•ì¸</button>`,
    {
      onMount(modal) {
        $("#btnNo", modal).onclick = closeModal;
        $("#btnYes", modal).onclick = async () => {
          closeModal();
          await onYes?.();
        };
      },
    }
  );
}

function openLoginModal() {
  openModal(
    "ë¡œê·¸ì¸",
    `
    <div class="split">
      <div>
        <div class="help">ë‹‰ë„¤ì„ ë˜ëŠ” í•™ë²ˆ</div>
        <input class="input" id="loginId" placeholder="ì˜ˆ: Test_02 ë˜ëŠ” 2035-101">
      </div>
      <div>
        <div class="help">ë¹„ë°€ë²ˆí˜¸</div>
        <input class="input" id="loginPw" type="password" placeholder="ë¹„ë°€ë²ˆí˜¸">
      </div>
    </div>
    <div style="height:10px"></div>
    <div class="help">ë¡œê·¸ì¸ í›„ ê¸€ì“°ê¸°/ëŒ“ê¸€/ì¢‹ì•„ìš”/ì‹ ê³ ê°€ ê°€ëŠ¥í•´ìš”.</div>
    `,
    `
    <button class="btn" id="goRegister">íšŒì›ê°€ì…</button>
    <button class="btn primary" id="doLogin">ë¡œê·¸ì¸</button>
    `,
    {
      onMount(modal) {
        $("#goRegister", modal).onclick = () => {
          closeModal();
          openRegisterModal();
        };
        $("#doLogin", modal).onclick = async () => {
          const identifier = $("#loginId", modal).value.trim();
          const password = $("#loginPw", modal).value.trim();
          if (!identifier || !password) return toast("ì…ë ¥ í•„ìš”", "ì•„ì´ë””/ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”", "warn");
          try {
            const r = await authLogin({ identifier, password });
            if (r && r.ok) {
              toast("ë¡œê·¸ì¸ ì„±ê³µ", `í™˜ì˜í•©ë‹ˆë‹¤, ${state.me?.nickname || ""}`, "ok");
              closeModal();
              render();
              await fetchPosts({ reset: true });
            }
          } catch (e) {
            toast("ë¡œê·¸ì¸ ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 3600);
          }
        };
      },
    }
  );
}

function openRegisterModal() {
  openModal(
    "íšŒì›ê°€ì…",
    `
    <div class="split">
      <div>
        <div class="help">ë‹‰ë„¤ì„ (2~16, ì˜ë¬¸/ìˆ«ì/í•œê¸€/_) </div>
        <input class="input" id="regNick" placeholder="ì˜ˆ: Test_02">
      </div>
      <div>
        <div class="help">í•™ë²ˆ (ì˜µì…˜)</div>
        <input class="input" id="regStudent" placeholder="ì˜ˆ: 2035-101">
      </div>
    </div>
    <div style="height:10px"></div>
    <div class="split">
      <div>
        <div class="help">ë¹„ë°€ë²ˆí˜¸ (4ì ì´ìƒ)</div>
        <input class="input" id="regPw" type="password" placeholder="ë¹„ë°€ë²ˆí˜¸">
      </div>
      <div>
        <div class="help">ë¹„ë°€ë²ˆí˜¸ í™•ì¸</div>
        <input class="input" id="regPw2" type="password" placeholder="ë¹„ë°€ë²ˆí˜¸ í™•ì¸">
      </div>
    </div>
    <div style="height:10px"></div>
    <div class="help">ê°€ì… í›„ ë‹‰ë„¤ì„/í•™ë²ˆ + ë¹„ë°€ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸í•  ìˆ˜ ìˆì–´ìš”.</div>
    `,
    `
    <button class="btn" id="goLogin">ë¡œê·¸ì¸</button>
    <button class="btn primary" id="doRegister">ê°€ì…</button>
    `,
    {
      onMount(modal) {
        $("#goLogin", modal).onclick = () => {
          closeModal();
          openLoginModal();
        };
        $("#doRegister", modal).onclick = async () => {
          const nickname = $("#regNick", modal).value.trim();
          const studentId = $("#regStudent", modal).value.trim();
          const password = $("#regPw", modal).value.trim();
          const password2 = $("#regPw2", modal).value.trim();

          if (!nickname || !password) return toast("ì…ë ¥ í•„ìš”", "ë‹‰ë„¤ì„/ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”", "warn");
          if (password.length < 4) return toast("ë¹„ë°€ë²ˆí˜¸", "4ì ì´ìƒìœ¼ë¡œ ì„¤ì •í•˜ì„¸ìš”", "warn");
          if (password !== password2) return toast("ë¹„ë°€ë²ˆí˜¸ í™•ì¸", "ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•Šì•„ìš”", "warn");

          try {
            const r = await authRegister({ nickname, password, studentId });
            if (r && r.ok) {
              toast("ê°€ì… ì™„ë£Œ", "ì´ì œ ë¡œê·¸ì¸í•´ ì£¼ì„¸ìš”", "ok");
              closeModal();
              openLoginModal();
            }
          } catch (e) {
            toast("ê°€ì… ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 3600);
          }
        };
      },
    }
  );
}

function openPostComposer() {
  if (!state.me) return toast("ë¡œê·¸ì¸ í•„ìš”", "ê¸€ì“°ê¸°ëŠ” ë¡œê·¸ì¸ í›„ ê°€ëŠ¥í•´ìš”", "warn");

  // draft load
  let draft = null;
  try {
    draft = JSON.parse(localStorage.getItem(STORAGE.draftPost) || "null");
  } catch {
    draft = null;
  }

  const catOptions = CATEGORIES.filter((c) => c.key !== "all")
    .map((c) => `<option value="${c.key}">${escapeHtml(c.label)}</option>`)
    .join("");

  openModal(
    "ìƒˆ ê¸€ ì‘ì„±",
    `
    <div class="row" style="justify-content:space-between">
      <div style="flex:1">
        <div class="help">ì¹´í…Œê³ ë¦¬</div>
        <select class="select" id="postCat">${catOptions}</select>
      </div>
      <label class="chip" style="gap:8px;flex:0 0 auto;margin-top:18px">
        <input type="checkbox" id="postAnon">
        <span>ìµëª…</span>
      </label>
    </div>

    <div style="height:10px"></div>

    <div class="help">ì œëª©</div>
    <input class="input" id="postTitle" placeholder="ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš” (ìµœëŒ€ 120ì)" maxlength="120">

    <div style="height:10px"></div>

    <div class="row" style="gap:8px;flex-wrap:wrap">
      <button class="btn" id="mdPH1" title="# í—¤ë”©">#</button>
      <button class="btn" id="mdPH2" title="## í—¤ë”©">##</button>
      <button class="btn" id="mdPH3" title="### í—¤ë”©">###</button>
      <button class="btn" id="mdPBold" title="**êµµê²Œ**"><b>B</b></button>
      <button class="btn" id="mdPQuote" title="> ì¸ìš©">â€œ</button>
      <button class="btn" id="mdPCode" title="```ì½”ë“œ```">{ }</button>
      <button class="btn" id="mdPImg" title="![](ë§í¬)">ğŸ–¼</button>
      <span class="help">ì´ë¯¸ì§€: <code>![](https://...)</code></span>
    </div>

    <div style="height:10px"></div>

    <div class="help">ë‚´ìš© (ë§ˆí¬ë‹¤ìš´ ì§€ì›)</div>
    <textarea class="input" id="postBody" maxlength="${MAX_BODY_MD}" placeholder="ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>

    <div class="row" style="justify-content:space-between;margin-top:10px">
      <div class="help">ë‚¨ì€ ê¸€ì: <span id="postRemain">${MAX_BODY_MD}</span></div>
      <div class="row" style="gap:8px">
        <button class="btn" id="btnPostPreview">ë¯¸ë¦¬ë³´ê¸°</button>
      </div>
    </div>

    <div style="height:10px"></div>
    <div class="md" id="postPreview" style="display:none;border:1px solid rgba(255,255,255,.10);border-radius:18px;padding:12px;background: rgba(0,0,0,.18)"></div>
    `,
    `
    <button class="btn" id="btnSaveDraft">ì„ì‹œì €ì¥</button>
    <button class="btn" id="btnClearDraft">ì´ˆê¸°í™”</button>
    <button class="btn primary" id="btnSubmitPost">ë“±ë¡</button>
    `,
    {
      onMount(modal) {
        const postCat = $("#postCat", modal);
        const postAnon = $("#postAnon", modal);
        const postTitle = $("#postTitle", modal);
        const postBody = $("#postBody", modal);
        const postRemain = $("#postRemain", modal);
        const postPreview = $("#postPreview", modal);

        // restore draft
        if (draft) {
          if (draft.category) postCat.value = draft.category;
          if (draft.anonymous) postAnon.checked = true;
          if (draft.title) postTitle.value = draft.title;
          if (draft.bodyMd) postBody.value = draft.bodyMd;
          postRemain.textContent = String(MAX_BODY_MD - postBody.value.length);
        } else {
          postCat.value = state.category !== "all" ? state.category : "free";
        }

        postBody.addEventListener("input", () => {
          postRemain.textContent = String(MAX_BODY_MD - postBody.value.length);
        });

        const applySnippet = (snippet, wrapSel = null) => {
          const ta = postBody;
          const start = ta.selectionStart || 0;
          const end = ta.selectionEnd || 0;
          const before = ta.value.slice(0, start);
          const sel = ta.value.slice(start, end);
          const after = ta.value.slice(end);

          let insert = snippet;
          if (wrapSel) {
            insert = wrapSel.replace("$", sel || "í…ìŠ¤íŠ¸");
          }
          ta.value = before + insert + after;
          ta.focus();
          ta.selectionStart = ta.selectionEnd = (before + insert).length;
          postRemain.textContent = String(MAX_BODY_MD - ta.value.length);
        };

        $("#mdPH1", modal).onclick = () => applySnippet("# ì œëª©\n");
        $("#mdPH2", modal).onclick = () => applySnippet("## ì œëª©\n");
        $("#mdPH3", modal).onclick = () => applySnippet("### ì œëª©\n");
        $("#mdPBold", modal).onclick = () => applySnippet("**$**", "**$**");
        $("#mdPQuote", modal).onclick = () => applySnippet("> ì¸ìš©ë¬¸\n");
        $("#mdPCode", modal).onclick = () => applySnippet("```txt\nì½”ë“œ\n```\n");
        $("#mdPImg", modal).onclick = () => applySnippet("![](https://ë§í¬)\n");

        $("#btnPostPreview", modal).onclick = async () => {
          await ensureMarkdownLibs();
          const md = postBody.value || "";
          postPreview.style.display = "block";
          postPreview.innerHTML = renderMarkdown(md);
        };

        $("#btnSaveDraft", modal).onclick = () => {
          const d = {
            category: postCat.value,
            anonymous: postAnon.checked,
            title: postTitle.value,
            bodyMd: postBody.value,
          };
          localStorage.setItem(STORAGE.draftPost, JSON.stringify(d));
          toast("ì„ì‹œì €ì¥", "ë¸Œë¼ìš°ì €ì— ì €ì¥í–ˆì–´ìš”", "ok");
        };

        $("#btnClearDraft", modal).onclick = () => {
          localStorage.removeItem(STORAGE.draftPost);
          postTitle.value = "";
          postBody.value = "";
          postAnon.checked = false;
          postPreview.style.display = "none";
          postRemain.textContent = String(MAX_BODY_MD);
          toast("ì´ˆê¸°í™”", "ì„ì‹œì €ì¥ë„ ì‚­ì œí–ˆì–´ìš”", "ok");
        };

        $("#btnSubmitPost", modal).onclick = async () => {
          const category = postCat.value;
          const title = postTitle.value.trim();
          const bodyMd = postBody.value.trim();
          const anonymous = postAnon.checked;

          if (!title || !bodyMd) return toast("ì…ë ¥ í•„ìš”", "ì œëª©/ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”", "warn");
          if (bodyMd.length > MAX_BODY_MD) return toast("ë„ˆë¬´ ê¹€", `ë‚´ìš©ì€ ${MAX_BODY_MD}ì ì´í•˜`, "warn");

          try {
            const r = await createPost({ category, title, bodyMd, anonymous });
            if (r && r.ok) {
              toast("ë“±ë¡ ì™„ë£Œ", "ê²Œì‹œê¸€ì´ ì˜¬ë¼ê°”ì–´ìš”", "ok");
              localStorage.removeItem(STORAGE.draftPost);
              closeModal();
              await fetchPosts({ reset: true });
              // ìƒì„¸ ë°”ë¡œ ì—´ê¸°
              if (r.postId) await fetchPost(r.postId);
            }
          } catch (e) {
            toast("ë“±ë¡ ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 4200);
          }
        };
      },
    }
  );
}

function openEditPostModal(post) {
  if (!state.me) return toast("ë¡œê·¸ì¸ í•„ìš”", "ìˆ˜ì •ì€ ë¡œê·¸ì¸ í›„ ê°€ëŠ¥í•´ìš”", "warn");

  const catOptions = CATEGORIES.filter((c) => c.key !== "all")
    .map((c) => `<option value="${c.key}" ${c.key === post.category ? "selected" : ""}>${escapeHtml(c.label)}</option>`)
    .join("");

  openModal(
    "ê¸€ ìˆ˜ì •",
    `
    <div class="row" style="justify-content:space-between">
      <div style="flex:1">
        <div class="help">ì¹´í…Œê³ ë¦¬</div>
        <select class="select" id="editCat">${catOptions}</select>
      </div>
      <label class="chip" style="gap:8px;flex:0 0 auto;margin-top:18px">
        <input type="checkbox" id="editAnon" ${post.anonymous ? "checked" : ""}>
        <span>ìµëª…</span>
      </label>
    </div>

    <div style="height:10px"></div>

    <div class="help">ì œëª©</div>
    <input class="input" id="editTitle" maxlength="120" value="${escapeHtml(post.title || "")}">

    <div style="height:10px"></div>

    <div class="help">ë‚´ìš© (ë§ˆí¬ë‹¤ìš´)</div>
    <textarea class="input" id="editBody" maxlength="${MAX_BODY_MD}">${escapeHtml(post.bodyMd || "")}</textarea>

    <div class="row" style="justify-content:space-between;margin-top:10px">
      <div class="help">ë³€ê²½ ì‚¬í•­ë§Œ ì €ì¥ë¼ìš”</div>
      <button class="btn" id="btnEditPreview">ë¯¸ë¦¬ë³´ê¸°</button>
    </div>
    <div style="height:10px"></div>
    <div class="md" id="editPreview" style="display:none;border:1px solid rgba(255,255,255,.10);border-radius:18px;padding:12px;background: rgba(0,0,0,.18)"></div>
    `,
    `
    <button class="btn" id="btnCancel">ì·¨ì†Œ</button>
    <button class="btn ok" id="btnSave">ì €ì¥</button>
    `,
    {
      onMount(modal) {
        const editCat = $("#editCat", modal);
        const editAnon = $("#editAnon", modal);
        const editTitle = $("#editTitle", modal);
        const editBody = $("#editBody", modal);
        const editPreview = $("#editPreview", modal);

        $("#btnCancel", modal).onclick = closeModal;

        $("#btnEditPreview", modal).onclick = async () => {
          await ensureMarkdownLibs();
          editPreview.style.display = "block";
          editPreview.innerHTML = renderMarkdown(editBody.value || "");
        };

        $("#btnSave", modal).onclick = async () => {
          const patch = {
            category: editCat.value,
            title: editTitle.value.trim(),
            bodyMd: editBody.value.trim(),
            anonymous: editAnon.checked,
          };
          if (!patch.title || !patch.bodyMd) return toast("ì…ë ¥ í•„ìš”", "ì œëª©/ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”", "warn");

          try {
            await editPost(post.id, patch);
            toast("ì €ì¥ë¨", "ê²Œì‹œê¸€ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤", "ok");
            closeModal();
            await fetchPosts({ reset: true });
            await fetchPost(post.id);
          } catch (e) {
            toast("ìˆ˜ì • ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 4200);
          }
        };
      },
    }
  );
}

function openReportModal(targetType, targetId) {
  if (!state.me) return toast("ë¡œê·¸ì¸ í•„ìš”", "ì‹ ê³ ëŠ” ë¡œê·¸ì¸ í›„ ê°€ëŠ¥í•´ìš”", "warn");

  openModal(
    "ì‹ ê³ ",
    `
    <div class="help">ì‚¬ìœ </div>
    <select class="select" id="repReason">
      <option value="ìš•ì„¤/ë¹„í•˜">ìš•ì„¤/ë¹„í•˜</option>
      <option value="ê´‘ê³ /ë„ë°°">ê´‘ê³ /ë„ë°°</option>
      <option value="í˜ì˜¤/ì°¨ë³„">í˜ì˜¤/ì°¨ë³„</option>
      <option value="ê°œì¸ì •ë³´">ê°œì¸ì •ë³´</option>
      <option value="ê¸°íƒ€" selected>ê¸°íƒ€</option>
    </select>
    <div style="height:10px"></div>
    <div class="help">ìƒì„¸(ì„ íƒ)</div>
    <textarea class="input" id="repDetail" placeholder="ìƒì„¸ ë‚´ìš©ì„ ì ì–´ì£¼ì„¸ìš” (ì„ íƒ)"></textarea>
    `,
    `
    <button class="btn" id="repCancel">ì·¨ì†Œ</button>
    <button class="btn danger" id="repSubmit">ì‹ ê³ </button>
    `,
    {
      onMount(modal) {
        $("#repCancel", modal).onclick = closeModal;
        $("#repSubmit", modal).onclick = async () => {
          const reason = $("#repReason", modal).value;
          const detail = $("#repDetail", modal).value.trim();
          try {
            await report(targetType, targetId, reason, detail);
            toast("ì‹ ê³  ì™„ë£Œ", "ê²€í†  ìš”ì²­ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤", "ok");
            closeModal();
          } catch (e) {
            toast("ì‹ ê³  ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 4200);
          }
        };
      },
    }
  );
}

/* ======================= COMMENT WIRING ======================= */
function wireCommentComposer(postId) {
  const me = state.me;
  const ta = $("#commentInput");
  const anon = $("#commentAnon");
  const preview = $("#commentPreview");
  const remain = $("#commentRemain");
  const btnPreview = $("#btnCommentPreview");
  const btnSend = $("#btnSendComment");

  if (!ta) return;

  const draftKey = STORAGE.draftCommentPrefix + postId;

  const updateRemain = () => {
    const left = MAX_COMMENT_MD - ta.value.length;
    if (remain) remain.textContent = String(left);
    localStorage.setItem(draftKey, ta.value);
  };

  ta.addEventListener("input", updateRemain);
  updateRemain();

  const insertSnippet = (snippet, wrapSel = null) => {
    if (!me) return;
    const start = ta.selectionStart || 0;
    const end = ta.selectionEnd || 0;
    const before = ta.value.slice(0, start);
    const sel = ta.value.slice(start, end);
    const after = ta.value.slice(end);

    let insert = snippet;
    if (wrapSel) insert = wrapSel.replace("$", sel || "í…ìŠ¤íŠ¸");

    ta.value = before + insert + after;
    ta.focus();
    ta.selectionStart = ta.selectionEnd = (before + insert).length;
    updateRemain();
  };

  $("#mdH1")?.addEventListener("click", () => insertSnippet("# ì œëª©\n"));
  $("#mdH2")?.addEventListener("click", () => insertSnippet("## ì œëª©\n"));
  $("#mdH3")?.addEventListener("click", () => insertSnippet("### ì œëª©\n"));
  $("#mdBold")?.addEventListener("click", () => insertSnippet("**$**", "**$**"));
  $("#mdQuote")?.addEventListener("click", () => insertSnippet("> ì¸ìš©ë¬¸\n"));
  $("#mdCode")?.addEventListener("click", () => insertSnippet("```txt\nì½”ë“œ\n```\n"));
  $("#mdImg")?.addEventListener("click", () => insertSnippet("![](https://ë§í¬)\n"));

  btnPreview?.addEventListener("click", async () => {
    if (!me) return;
    await ensureMarkdownLibs();
    preview.style.display = "block";
    preview.innerHTML = renderMarkdown(ta.value || "");
  });

  btnSend?.addEventListener("click", async () => {
    if (!me) return;
    const bodyMd = ta.value.trim();
    if (!bodyMd) return toast("ì…ë ¥ í•„ìš”", "ëŒ“ê¸€ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”", "warn");
    if (bodyMd.length > MAX_COMMENT_MD) return toast("ë„ˆë¬´ ê¹€", `ëŒ“ê¸€ì€ ${MAX_COMMENT_MD}ì ì´í•˜`, "warn");

    try {
      const r = await createComment(postId, { bodyMd, anonymous: !!anon?.checked });
      if (r && r.ok) {
        toast("ëŒ“ê¸€ ë“±ë¡", "ì™„ë£Œ", "ok");
        ta.value = "";
        if (preview) {
          preview.style.display = "none";
          preview.innerHTML = "";
        }
        localStorage.removeItem(draftKey);
        updateRemain();
        await fetchComments(postId);
        await fetchPost(postId);
        // ëª©ë¡ ë°˜ì˜
        await fetchPosts({ reset: true });
      }
    } catch (e) {
      toast("ëŒ“ê¸€ ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 4200);
    }
  });
}

function wireCommentListActions(postId) {
  const list = $("#commentList");
  if (!list) return;

  // like comment
  $$("[data-like-comment]", list).forEach((btn) => {
    btn.addEventListener("click", async () => {
      if (!state.me) return toast("ë¡œê·¸ì¸ í•„ìš”", "ì¢‹ì•„ìš”ëŠ” ë¡œê·¸ì¸ í›„ ê°€ëŠ¥í•´ìš”", "warn");
      const id = btn.getAttribute("data-like-comment");
      try {
        const r = await toggleLike("comment", id);
        toast(r.liked ? "ì¢‹ì•„ìš”" : "ì¢‹ì•„ìš” ì·¨ì†Œ", "", "ok", 1400);
      } catch (e) {
        toast("ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 2600);
      }
    });
  });

  // report comment
  $$("[data-report-comment]", list).forEach((btn) => {
    btn.addEventListener("click", () => {
      const id = btn.getAttribute("data-report-comment");
      openReportModal("comment", id);
    });
  });

  // reply helper (not threaded, but quotes)
  $$("[data-reply]", list).forEach((btn) => {
    btn.addEventListener("click", () => {
      if (!state.me) return toast("ë¡œê·¸ì¸ í•„ìš”", "ë‹µê¸€ì€ ë¡œê·¸ì¸ í›„ ê°€ëŠ¥í•´ìš”", "warn");
      const author = btn.getAttribute("data-reply-author") || "ìµëª…";
      const ta = $("#commentInput");
      if (!ta) return;
      const line = `> @${author} \n`;
      ta.value = (ta.value ? ta.value + "\n" : "") + line;
      ta.focus();
      toast("ë‹µê¸€", "ì¸ìš©ë¬¸ì´ ì…ë ¥ë˜ì—ˆì–´ìš”", "ok", 1400);
    });
  });
}

/* ======================= INIT ======================= */
async function init() {
  injectBaseStylesIfNeeded();
  loadUiPrefs();
  render();

  // Realtime connect (non-blocking)
  wsConnect();

  // ensure markdown libs (lazy) but preload quietly
  ensureMarkdownLibs().catch(() => {});

  // silent auth check
  await authMeSilent();

  // initial load
  await fetchPosts({ reset: true });
}

init().catch((e) => {
  console.error(e);
  toast("ì´ˆê¸°í™” ì‹¤íŒ¨", e.message || "ì˜¤ë¥˜", "bad", 6000);
});
